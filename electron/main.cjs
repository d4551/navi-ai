const {
  app,
  BrowserWindow,
  ipcMain,
  dialog,
  shell,
  session,
} = require('electron')
const path = require('path')
const fs = require('fs')
const isDev = process.env.NODE_ENV === 'development' || !app.isPackaged

let mainWindow
// Optional secure storage
let keytar = null
try {
  keytar = require('keytar')
} catch {
  keytar = null
}

// Helper to ignore the ipc event parameter and forward remaining args
const ignoreEvent = listener => {
  return (_event, ...args) => listener(...args)
}

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 1000,
    minHeight: 600,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      enableRemoteModule: false,
      // Always resolve preload relative to this file so dev/prod work the same
      preload: path.join(__dirname, 'preload.cjs'),
    },
    show: false,
  })

  // Robust loader with retry & fallback
  const loadDevServer = () => {
    const envPort = Number(process.env.VITE_PORT) || 5173
    const candidates = [envPort, 5173, 5175, 5180, 3000]
    const portsToTry = [...new Set(candidates)].filter(Boolean)

    let current = 0
    const tryPort = () => {
      const port = portsToTry[current]
      const url = `http://127.0.0.1:${port}`
      const onFail = (_e, _code, desc) => {
        const msg = String(desc || '')
        if (/ERR_CONNECTION_REFUSED|ERR_NAME_NOT_RESOLVED/.test(msg)) {
          // Retry current port a few times
          let attempts = 0
          const maxAttempts = 8
          const interval = globalThis.setInterval(() => {
            attempts++
            mainWindow.loadURL(url).catch(() => {})
            if (attempts >= maxAttempts) {
              globalThis.clearInterval(interval)
              current++
              if (current < portsToTry.length) {
                tryPort()
              } else {
                loadDistOrShowHelp(url, msg)
              }
            }
          }, 700)
        } else {
          // Unexpected error: try next port or fall back
          current++
          if (current < portsToTry.length) {
            tryPort()
          } else {
            loadDistOrShowHelp(url, msg)
          }
        }
      }
      mainWindow.webContents.once('did-fail-load', onFail)
      mainWindow.loadURL(url).catch(() => {})
    }

    tryPort()
    if (isDev) mainWindow.webContents.openDevTools({ mode: 'detach' })
  }

  const loadDistOrShowHelp = (devUrl, lastError) => {
    const indexPath = path.resolve(__dirname, '..', 'dist', 'index.html')
    if (fs.existsSync(indexPath)) {
      mainWindow.loadFile(indexPath).catch(() => {})
      return
    }
    const helpHtml = `<!doctype html><html><head><meta charset='utf-8'/><title>NAVI Dev Server Not Running</title><style>body{font-family:system-ui;padding:2rem;line-height:1.4;background:#111;color:#eee} code{background:#222;padding:2px 4px;border-radius:4px} h1{margin-top:0;color:#ffb347} a{color:#6cf}</style></head><body><h1>Dev server not running</h1><p>Electron attempted to load <code>${devUrl}</code> but received <strong>${lastError || 'connection error'}</strong>.</p><h2>Start Development</h2><ol><li>In a terminal run <code>npm run electron-dev</code> (auto starts Vite then Electron)</li><li>Or run in two terminals:<br/><code>npm run dev</code> and then <code>npm run electron</code></li></ol><h2>Build & Run Production</h2><p>Build renderer then start Electron:<br/><code>npm run build && npm run electron</code></p><h2>Troubleshooting</h2><ul><li>Check for a port clash on 5173; set a custom port: <code>VITE_PORT=5180 npm run electron-dev:port</code></li><li>Verify no VPN/firewall is blocking localhost</li><li>If you recently upgraded Vite/Electron, clear cache: remove <code>node_modules/.vite</code> then re-run install</li></ul><p>This helper page is generated by <code>electron/main.cjs</code> for convenience.</p></body></html>`
    mainWindow.loadURL(
      'data:text/html;base64,' + Buffer.from(helpHtml).toString('base64')
    )
  }

  if (isDev) {
    loadDevServer()
  } else {
    loadDistOrShowHelp('http://127.0.0.1:5173')
  }

  mainWindow.once('ready-to-show', () => {
    mainWindow.show()
  })

  // Harden external navigation: open external links in default browser
  mainWindow.webContents.setWindowOpenHandler(({ url }) => {
    try {
      shell.openExternal(url)
    } catch (error) {
      console.warn('Failed to open external URL:', error)
    }
    return { action: 'deny' }
  })
  mainWindow.webContents.on('will-navigate', (event, url) => {
    try {
      const { URL } = require('url')
      const target = new URL(url)
      if (
        target.origin !== 'null' &&
        !/^https?:\/\/127\.0\.0\.1(?::\d+)?$/.test(target.origin)
      ) {
        event.preventDefault()
        shell.openExternal(url)
      }
    } catch (error) {
      console.warn('Failed to handle navigation:', error)
    }
  })

  mainWindow.on('closed', () => {
    mainWindow = null
  })
}

app.whenReady().then(() => {
  createWindow()

  // Add handler for app-report-error to prevent repeated error logs
  session.defaultSession.on('app-report-error', (event, error) => {
    console.warn('App report error:', error)
    // Prevent default behavior which logs repeatedly
    event.preventDefault()
  })

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow()
    }
  })
})

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

// CANONICAL AI Service (main-process only) - Single Source of Truth
let aiService = null
// Consolidate to services/AIService.cjs and remove duplicate ai/aiService.cjs
const { MainAIService } = require('./services/AIService.cjs')

// Import Interview Service
const { InterviewService } = require('./InterviewService.cjs')
let interviewService = null
// Job matching service (CJS)
const { JobMatchingService } = require('./services/JobMatchingService.cjs')
const jobMatching = new JobMatchingService()

async function initializeAIService(apiKey, model = 'gemini-1.5-flash') {
  // Prevent repeated identical initializations
  const sig = `${(apiKey || '').trim()}::${(model || '').trim()}`
  if (global.__lastAIInitSig === sig && aiService) {
    return { success: true, model }
  }
  try {
    if (!aiService) {
      aiService = new MainAIService()
    }
    const result = await aiService.initialize(apiKey, model)

    // Create interview service with dependency injection
    if (!interviewService) {
      interviewService = new InterviewService({
        model: {
          // Adapter to align with expected interface
          generateContent: async request => {
            const prompt =
              typeof request === 'string'
                ? request
                : request?.contents?.[0]?.parts?.[0]?.text || ''
            const { text } = await aiService.generateText(prompt, {
              options: {},
            })
            return { response: { text: () => text } }
          },
        },
        modelId: model,
        generateContent: async (prompt, options = {}) => {
          const result = await aiService.generateText(prompt, {
            systemInstructions: options.systemPrompt,
            options,
          })
          return result.text
        },
      })
    } else {
      // Update existing service's AI reference
      interviewService.aiService = {
        model: {
          generateContent: async request => {
            const prompt =
              typeof request === 'string'
                ? request
                : request?.contents?.[0]?.parts?.[0]?.text || ''
            const { text } = await aiService.generateText(prompt, {
              options: {},
            })
            return { response: { text: () => text } }
          },
        },
        modelId: model,
        generateContent: async (prompt, options = {}) => {
          const result = await aiService.generateText(prompt, {
            systemInstructions: options.systemPrompt,
            options,
          })
          return result.text
        },
      }
    }

    console.log(`CANONICAL AI Service initialized with model: ${result.model}`)
    global.__lastAIInitSig = sig
    return result
  } catch (error) {
    console.error('Failed to initialize CANONICAL AI service:', error)
    aiService = null
    throw error
  }
}

// Interview IPC handlers are now registered by InterviewService itself
// No need to register them here to avoid conflicts

// Secure IPC handlers
ipcMain.handle('ai-initialize', async (_event, { apiKey, model }) => {
  try {
    const result = await initializeAIService(apiKey, model)
    return { success: true, data: result }
  } catch (error) {
    return { success: false, error: error.message }
  }
})

// New secure AI handlers with typed contracts
ipcMain.handle('ai-init', async (_event, { apiKey, model }) => {
  try {
    const result = await initializeAIService(apiKey, model)
    return result
  } catch (error) {
    console.error('AI init error:', error)
    return { success: false, error: error.message }
  }
})

ipcMain.handle(
  'ai-generate-text',
  async (_event, { prompt, systemInstructions, options = {} }) => {
    try {
      if (!aiService)
        throw new Error(
          'AI service not initialized. Please configure your API key first.'
        )
      const result = await aiService.generateText(prompt, {
        systemInstructions,
        options,
      })
      return result.text
    } catch (error) {
      console.error('AI generation error:', error)
      throw error
    }
  }
)

// CANONICAL AI status using new service architecture
ipcMain.handle('ai-status', async () => {
  try {
    if (!aiService) {
      return { initialized: false }
    }
    return await aiService.getStatus()
  } catch (error) {
    return {
      initialized: false,
      error: error.message,
    }
  }
})

// Legacy handler for backward compatibility
ipcMain.handle(
  'ai-generate-content',
  async (_event, { prompt, systemInstructions, options = {} }) => {
    try {
      if (!aiService)
        throw new Error(
          'AI service not initialized. Please configure your API key first.'
        )
      const { text, usageMetadata, latencyMs } = await aiService.generateText(
        prompt,
        { systemInstructions, options }
      )
      return { success: true, data: { text, usageMetadata, latencyMs } }
    } catch (error) {
      console.error('AI generation error:', error)
      return { success: false, error: error.message }
    }
  }
)

// Real streaming generation using CANONICAL SDK stream API
ipcMain.on(
  'ai-stream-generate-start',
  async (event, { requestId, prompt, systemInstructions, options = {} }) => {
    if (!aiService) {
      event.sender.send('ai-stream-chunk', {
        requestId,
        error: 'AI not initialized',
      })
      return
    }
    try {
      const iterator = aiService.streamText(prompt, {
        systemInstructions,
        options,
      })
      for await (const result of iterator) {
        if (streamCancelSet.has(requestId)) {
          event.sender.send('ai-stream-complete', {
            requestId,
            cancelled: true,
          })
          streamCancelSet.delete(requestId)
          return
        }

        if (result.chunk) {
          event.sender.send('ai-stream-chunk', {
            requestId,
            chunk: result.chunk,
          })
        }

        if (result.done) {
          event.sender.send('ai-stream-complete', {
            requestId,
            latencyMs: result.latencyMs,
          })
          break
        }
      }
    } catch (error) {
      event.sender.send('ai-stream-chunk', { requestId, error: error.message })
      event.sender.send('ai-stream-complete', {
        requestId,
        error: error.message,
      })
    }
  }
)

// Enhanced cancellation support
const streamCancelSet = new Set()
ipcMain.on(
  'ai-stream-cancel',
  ignoreEvent(requestId => {
    streamCancelSet.add(requestId)
    if (aiService) {
      aiService.cancelStream(requestId)
    }
  })
)

// CANONICAL skill mapping IPC using new service architecture
ipcMain.handle('ai-skill-map', async (_event, { experience, options = {} }) => {
  try {
    if (!aiService) throw new Error('AI service not initialized')

    const prompt = `Analyze this experience and create comprehensive skill mappings for professional transition:

EXPERIENCE: ${JSON.stringify(experience)}
OPTIONS: ${JSON.stringify(options)}

Return JSON array with format:
[{"skill": "original skill/activity", "professionalSkill": "professional equivalent", "explanation": "how it transfers with examples", "industries": ["relevant industries"], "demandLevel": "high|medium|low", "examples": ["specific scenarios"]}]`

    const system =
      'You are a career transition specialist expert at mapping diverse experiences to professional skills. Return valid JSON array only, no markdown.'
    const { text } = await aiService.generateText(prompt, {
      systemInstructions: system,
      options: { temperature: 0.4, maxTokens: 2048 },
    })

    try {
      return { success: true, data: JSON.parse(text) }
    } catch (parseError) {
      console.warn('Failed to parse skill mapping response:', parseError)
      return { success: true, data: [] }
    }
  } catch (error) {
    return { success: false, error: error.message }
  }
})

// CANONICAL resume scoring IPC using new service architecture
ipcMain.handle(
  'ai-resume-score',
  async (_event, { resumeData, jobTitle, options = {} }) => {
    try {
      if (!aiService) throw new Error('AI service not initialized')

      const prompt = `Analyze this resume for ${jobTitle || 'target professional role'} and provide comprehensive scoring:

RESUME DATA: ${JSON.stringify(resumeData)}
TARGET ROLE: ${jobTitle || 'general professional position'}

Return JSON with exact format:
{"score": number (0-100), "strengths": [string array], "improvements": [string array], "keywords": [string array of missing important keywords]}`

      const system =
        'You are an expert resume reviewer and ATS specialist with 15+ years experience. Focus on actionable feedback and ATS optimization. Only output valid JSON, no markdown.'
      const { text } = await aiService.generateText(prompt, {
        systemInstructions: system,
        options: { temperature: 0.3, maxTokens: 1024, ...options },
      })

      try {
        return { success: true, data: JSON.parse(text) }
      } catch (parseError) {
        console.warn('Failed to parse resume score response:', parseError)
        return {
          success: true,
          data: { score: 75, strengths: [], improvements: [], keywords: [] },
        }
      }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }
)

// CANONICAL models listing using new service architecture
ipcMain.handle('ai-list-models', async () => {
  try {
    if (!aiService) {
      throw new Error('AI service not initialized')
    }

    // Use the canonical service's curated model list
    return await aiService.listModels()
  } catch (error) {
    return { success: false, error: error.message }
  }
})

// Media device permissions and audio processing
ipcMain.handle('media-get-devices', async () => {
  // Return success - actual enumeration happens in renderer with proper permissions
  return {
    success: true,
    message: 'Device enumeration should be handled in renderer',
  }
})

ipcMain.handle('media-request-permissions', async () => {
  // Permissions are handled by renderer's getUserMedia
  return { success: true, message: 'Permissions handled in renderer process' }
})

// New typed audio endpoints (STT/TTS)
ipcMain.handle(
  'audio-stt-transcribe',
  ignoreEvent(async request => {
    try {
      if (!aiService) throw new Error('AI service not initialized')
      const provider = request?.provider || 'gemini'
      if (provider !== 'gemini') {
        return { success: false, error: 'Only Gemini STT supported in main' }
      }
      const { audioData, mimeType, language } = request || {}
      if (!audioData || !mimeType) {
        throw new Error('Missing audioData or mimeType')
      }
      const { text } = await aiService.transcribeAudio({
        base64: audioData,
        mimeType,
        language,
      })
      return { success: true, transcript: text || '', confidence: 0.9 }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle(
  'audio-tts-speak',
  ignoreEvent(async request => {
    try {
      if (!aiService) {
        throw new Error('AI service not initialized')
      }
      // For now, delegate TTS playback to renderer unless audio generation is implemented
      if (request.provider === 'gemini') {
        const { text, voice, rate } = request
        const audioContent = await aiService.generateSpeech({
          text,
          voice,
          rate,
        })
        return { success: true, audioData: audioContent }
      }
      return { success: true, route: 'renderer' }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
)

// Audio processing handlers for interview functionality
ipcMain.handle(
  'audio-process-speech',
  ignoreEvent(async ({ audioBlob, language = 'en-US', mimeType }) => {
    try {
      // Prefer real STT if AI service is initialized and we have data
      if (aiService && audioBlob) {
        // Normalize to base64 + mime
        const norm = (() => {
          if (typeof audioBlob === 'string') {
            return { base64: audioBlob, mime: mimeType || 'audio/wav' }
          }
          if (audioBlob && typeof audioBlob === 'object') {
            if (typeof audioBlob.base64 === 'string')
              return {
                base64: audioBlob.base64,
                mime: audioBlob.mimeType || mimeType || 'audio/wav',
              }
            if (typeof audioBlob.data === 'string')
              return {
                base64: audioBlob.data,
                mime: audioBlob.mimeType || mimeType || 'audio/wav',
              }
            if (Array.isArray(audioBlob.data)) {
              // Typed array serialized; convert to base64
              const buf = Buffer.from(Uint8Array.from(audioBlob.data))
              return {
                base64: buf.toString('base64'),
                mime:
                  audioBlob.mimeType || mimeType || 'application/octet-stream',
              }
            }
          }
          return null
        })()
        if (norm && norm.base64) {
          try {
            const { text } = await aiService.transcribeAudio({
              base64: norm.base64,
              mimeType: norm.mime,
              language,
            })
            if (text && text.trim()) {
              return { success: true, transcript: text.trim(), confidence: 0.9 }
            }
          } catch (e) {
            console.warn(
              '[audio] AI transcription failed, falling back to offline analysis:',
              e?.message || e
            )
          }
        }
      }

      // Offline lightweight analysis fallback (no external API)
      // Attempt to parse WAV header for duration and channels; else report size only
      let bytes = 0
      let durationSec = 0
      let channels = 0
      let sampleRate = 0
      let guessedType = mimeType || audioBlob?.mimeType || 'unknown'
      try {
        let buf
        if (typeof audioBlob === 'string') {
          buf = Buffer.from(audioBlob, 'base64')
        } else if (
          audioBlob &&
          typeof audioBlob === 'object' &&
          typeof audioBlob.data === 'string'
        ) {
          buf = Buffer.from(audioBlob.data, 'base64')
        } else if (
          audioBlob &&
          typeof audioBlob === 'object' &&
          Array.isArray(audioBlob.data)
        ) {
          buf = Buffer.from(Uint8Array.from(audioBlob.data))
        }
        if (buf) {
          bytes = buf.length
          // WAV signature: RIFF....WAVE
          // WAV signature: RIFF....WAVE
          if (
            buf.subarray(0, 4).toString('ascii') === 'RIFF' &&
            buf.subarray(8, 12).toString('ascii') === 'WAVE'
          ) {
            guessedType = 'audio/wav'
            // Find 'fmt ' chunk
            let offset = 12
            let dataSize = 0
            while (offset + 8 <= buf.length) {
              const chunkId = buf.subarray(offset, offset + 4).toString('ascii')
              const chunkSize = buf.readUInt32LE(offset + 4)
              if (chunkId === 'fmt ') {
                channels = buf.readUInt16LE(offset + 10)
                sampleRate = buf.readUInt32LE(offset + 12)
                const bitsPerSample = buf.readUInt16LE(offset + 22)
                // Find subsequent 'data' chunk to compute duration
                let scan = offset + 8 + chunkSize
                while (scan + 8 <= buf.length) {
                  const id2 = buf.subarray(scan, scan + 4).toString('ascii')
                  const sz2 = buf.readUInt32LE(scan + 4)
                  if (id2 === 'data') {
                    dataSize = sz2
                    break
                  }
                  scan += 8 + sz2
                }
                if (dataSize > 0 && sampleRate && channels && bitsPerSample) {
                  durationSec =
                    dataSize / (sampleRate * channels * (bitsPerSample / 8))
                }
                break
              }
              offset += 8 + chunkSize
            }
          }
        }
      } catch {
        // Ignore parse errors for WAV header analysis
      }

      const sizeKb = bytes ? `${(bytes / 1024).toFixed(1)} KB` : 'unknown size'
      const durStr = durationSec
        ? `${durationSec.toFixed(2)}s`
        : 'unknown duration'
      const meta = `format=${guessedType}${sampleRate ? `, ${sampleRate}Hz` : ''}${channels ? `, ${channels}ch` : ''}`
      const transcript = `Audio captured (${meta}); duration=${durStr}; size=${sizeKb}. Offline analysis (no STT configured).`
      return { success: true, transcript, confidence: 0.5 }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle(
  'secure-store-get',
  ignoreEvent(async key => {
    try {
      if (keytar) {
        const value = await keytar.getPassword('NAVI', key)
        return { success: true, data: value || null }
      } else {
        if (!global.secureStore) return { success: true, data: null }
        const value = global.secureStore.get(key)
        return { success: true, data: value || null }
      }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
)

// File system operations
ipcMain.handle(
  'show-save-dialog',
  ignoreEvent(async options => {
    const result = await dialog.showSaveDialog(mainWindow, options)
    return result
  })
)

ipcMain.handle(
  'show-open-dialog',
  ignoreEvent(async options => {
    const result = await dialog.showOpenDialog(mainWindow, options)
    return result
  })
)

ipcMain.handle(
  'open-external',
  ignoreEvent(async url => {
    await shell.openExternal(url)
    return { success: true }
  })
)

ipcMain.handle('get-platform', () => {
  return process.platform
})

// Development helpers and error reporting
ipcMain.handle('dev-open-devtools', () => {
  try {
    if (mainWindow && mainWindow.webContents) {
      mainWindow.webContents.openDevTools()
    }
    return { success: true }
  } catch (error) {
    return { success: false, error: error.message }
  }
})

ipcMain.handle('dev-reload', () => {
  try {
    if (mainWindow) mainWindow.reload()
    return { success: true }
  } catch (error) {
    return { success: false, error: error.message }
  }
})

ipcMain.handle(
  'app-report-error',
  ignoreEvent(async errorData => {
    try {
      const msg =
        typeof errorData === 'string' ? errorData : JSON.stringify(errorData)
      console.error('[Renderer Error]', msg)
      return { success: true }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
)

// Add active recordings set
const activeRecordings = new Set()

ipcMain.handle(
  'audio-start-recording',
  ignoreEvent(async ({ deviceId }) => {
    try {
      const streamId = `stream_${Date.now()}`
      activeRecordings.add(streamId)
      mainWindow.webContents.send('renderer-start-recording', {
        streamId,
        deviceId,
      })
      return { success: true, streamId }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle(
  'audio-stop-recording',
  ignoreEvent(async ({ streamId }) => {
    try {
      if (!mainWindow) throw new Error('No active window')
      if (!activeRecordings.has(streamId)) throw new Error('Unknown stream')

      const audioData = await new Promise((resolve, reject) => {
        const successChannel = `audio-recording-complete-${streamId}`
        const errorChannel = `audio-recording-error-${streamId}`

        const cleanup = () => {
          ipcMain.removeAllListeners(successChannel)
          ipcMain.removeAllListeners(errorChannel)
          activeRecordings.delete(streamId)
        }

        ipcMain.once(successChannel, (_evt, buffer) => {
          cleanup()
          resolve(buffer)
        })

        ipcMain.once(errorChannel, (_evt, message) => {
          cleanup()
          reject(new Error(message))
        })

        mainWindow.webContents.send('renderer-stop-recording', { streamId })
      })

      return { success: true, audioData }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle(
  'audio-play',
  ignoreEvent(async ({ audioData }) => {
    try {
      if (!mainWindow) throw new Error('No active window')
      mainWindow.webContents.send('renderer-play-audio', { audioData })
      return { success: true }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
)

// Missing IPC handlers for complete API surface
ipcMain.handle(
  'fs-show-open-dialog',
  ignoreEvent(async options => {
    const result = await dialog.showOpenDialog(mainWindow, options)
    return result
  })
)

ipcMain.handle(
  'fs-show-save-dialog',
  ignoreEvent(async options => {
    const result = await dialog.showSaveDialog(mainWindow, options)
    return result
  })
)

ipcMain.handle(
  'fs-read-file',
  ignoreEvent(async ({ filePath }) => {
    try {
      // Security: Only allow reading user-selected files (would be enhanced with proper sandboxing)
      const content = require('fs').readFileSync(filePath, 'utf8')
      return { success: true, content }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle(
  'fs-write-file',
  ignoreEvent(async ({ filePath, data }) => {
    try {
      require('fs').writeFileSync(filePath, data, 'utf8')
      return { success: true }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
)
ipcMain.handle(
  'db-create-backup',
  ignoreEvent(async ({ defaultPath }) => {
    try {
      const { databaseManager } = require('./services/DatabaseManager.cjs')
      if (!databaseManager) {
        throw new Error('Database manager not available')
      }
      const suggestedName = `navi-db-backup-${new Date().toISOString().slice(0, 10)}.db`
      const opts = {
        title: 'Save Database Backup',
        defaultPath: defaultPath || suggestedName,
        filters: [{ name: 'SQLite Database', extensions: ['db', 'sqlite'] }],
      }
      const result = await dialog.showSaveDialog(mainWindow, opts)
      if (result.canceled || !result.filePath) {
        return { success: false, error: 'User cancelled' }
      }
      await databaseManager.backup(result.filePath)
      return { success: true, filePath: result.filePath }
    } catch (error) {
      console.error('[DB] Backup failed:', error)
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle('db-get-backup-info', async () => {
  try {
    const { databaseManager } = require('./services/DatabaseManager.cjs')
    const info = await databaseManager.getBackupInfo()
    return { success: true, data: info }
  } catch (error) {
    console.error('[DB] Get backup info failed:', error)
    return { success: false, error: error.message }
  }
})

// App settings handlers (electron-store backed, non-secret)
// Support both CJS (<= v8) and ESM-only (>= v10) versions of electron-store
let prefStore = null
async function ensurePrefStore() {
  if (prefStore) return prefStore
  try {
    let StoreMod
    try {
      // Try CommonJS require first
      StoreMod = require('electron-store')
      StoreMod = StoreMod?.default ?? StoreMod
    } catch {
      // Fallback to dynamic import for ESM-only versions
      const esm = await import('electron-store')
      StoreMod = esm.default || esm
    }
    prefStore = new StoreMod({ name: 'preferences' })
  } catch (error) {
    console.warn(
      '[prefs] electron-store not available, falling back to memory:',
      error.message
    )
    prefStore = {
      _data: {},
      get(key, def) {
        return this._data[key] ?? def
      },
      set(key, val) {
        this._data[key] = val
      },
    }
  }
  return prefStore
}

// Cache management
const statsCacheFile = path.join(__dirname, 'cache', 'studio-stats.json')
const studioDataFile = path.join(__dirname, 'cache', 'studios-normalized.json')
const interviewSuggestionsFile = path.join(
  __dirname,
  'cache',
  'interview-suggestions.json'
)

// Ensure cache directory exists
const cacheDir = path.dirname(statsCacheFile)
if (!fs.existsSync(cacheDir)) {
  fs.mkdirSync(cacheDir, { recursive: true })
}

let studioStatsCache = {}
let normalizedStudiosCache = {}
let normalizedStudiosVersion = 1
let interviewStepSuggestions = {}

// Load existing cache data
try {
  if (fs.existsSync(statsCacheFile)) {
    studioStatsCache = JSON.parse(fs.readFileSync(statsCacheFile, 'utf8')) || {}
  }
  if (fs.existsSync(studioDataFile)) {
    const raw = JSON.parse(fs.readFileSync(studioDataFile, 'utf8'))
    if (raw && raw.version && Array.isArray(raw.data)) {
      normalizedStudiosVersion = raw.version
      normalizedStudiosCache = raw.data.reduce((acc, s) => {
        if (s?.id) acc[s.id] = s
        return acc
      }, {})
    } else if (raw && raw.__meta && raw.__meta.version && raw.__meta.data) {
      normalizedStudiosVersion = raw.__meta.version
      normalizedStudiosCache = raw.__meta.data
    } else {
      normalizedStudiosCache = raw
    }
  }
  if (fs.existsSync(interviewSuggestionsFile)) {
    try {
      interviewStepSuggestions =
        JSON.parse(fs.readFileSync(interviewSuggestionsFile, 'utf8')) || {}
    } catch (e) {
      console.warn('[suggestions] load failed', e.message)
    }
  }
} catch (e) {
  console.warn('[studio-stats] failed to load cache', e.message)
}

function persistStudioStatsCache() {
  try {
    fs.writeFileSync(
      statsCacheFile,
      JSON.stringify(studioStatsCache, null, 2),
      'utf8'
    )
  } catch (e) {
    console.warn('[studio-stats] persist failed', e.message)
  }
}

function persistNormalizedStudios() {
  try {
    fs.writeFileSync(
      studioDataFile,
      JSON.stringify(
        {
          version: normalizedStudiosVersion,
          data: Object.values(normalizedStudiosCache),
        },
        null,
        2
      ),
      'utf8'
    )
  } catch (e) {
    console.warn('[studios-normalized] persist failed', e.message)
  }
}

function persistInterviewSuggestions() {
  try {
    fs.writeFileSync(
      interviewSuggestionsFile,
      JSON.stringify(interviewStepSuggestions, null, 2),
      'utf8'
    )
  } catch (e) {
    console.warn('[suggestions] persist failed', e.message)
  }
}

function migrateStudiosIfNeeded(targetVersion = 2) {
  if (normalizedStudiosVersion >= targetVersion) return
  // Example migration logic (v2): ensure each studio has meta.normalizedVersion and lastSync timestamp
  Object.keys(normalizedStudiosCache).forEach(id => {
    const s = normalizedStudiosCache[id]
    if (!s.meta) s.meta = {}
    if (!s.meta.normalizedVersion) s.meta.normalizedVersion = targetVersion
    if (!s.meta.lastSync) s.meta.lastSync = new Date().toISOString()
  })
  normalizedStudiosVersion = targetVersion
  persistNormalizedStudios()
}

migrateStudiosIfNeeded()

ipcMain.handle('studio-stats-get', async (_event, { studioId }) => {
  try {
    const entry = studioStatsCache[studioId]
    return { success: true, data: entry || null }
  } catch (e) {
    return { success: false, error: e.message }
  }
})

ipcMain.handle('studio-stats-set', async (_event, { studioId, stats }) => {
  try {
    if (!studioId || typeof stats !== 'object')
      throw new Error('Invalid params')
    studioStatsCache[studioId] = {
      ...stats,
      lastUpdated: stats.lastUpdated || new Date().toISOString(),
    }
    persistStudioStatsCache()
    return { success: true }
  } catch (e) {
    return { success: false, error: e.message }
  }
})
ipcMain.handle('studios-import-normalized', async (_event, studios) => {
  try {
    if (!Array.isArray(studios)) throw new Error('studios should be array')
    let count = 0
    for (const s of studios) {
      if (!s?.id) continue
      normalizedStudiosCache[s.id] = { ...normalizedStudiosCache[s.id], ...s }
      count++
    }
    // Bump version if structural change (simplified heuristic): new import after migration
    normalizedStudiosVersion = Math.max(normalizedStudiosVersion, 2)
    persistNormalizedStudios()
    return { success: true, imported: count }
  } catch (e) {
    return { success: false, error: e.message }
  }
})

ipcMain.handle('studios-list-normalized', async () => {
  try {
    return {
      success: true,
      version: normalizedStudiosVersion,
      data: Object.values(normalizedStudiosCache),
    }
  } catch (e) {
    return { success: false, error: e.message }
  }
})

ipcMain.handle('studios-get-normalized', async (_event, { id }) => {
  try {
    if (!id) throw new Error('id required')
    return {
      success: true,
      version: normalizedStudiosVersion,
      data: normalizedStudiosCache[id] || null,
    }
  } catch (e) {
    return { success: false, error: e.message }
  }
})

// Interview step suggestions persistence
ipcMain.handle('interview-suggestions-get-all', async () => {
  try {
    return { success: true, data: interviewStepSuggestions }
  } catch (e) {
    return { success: false, error: e.message }
  }
})
ipcMain.handle(
  'interview-suggestions-set',
  async (_event, { stepKey, record, suggestions, ts, model, rationale }) => {
    try {
      if (!stepKey) throw new Error('stepKey required')
      let finalRecord
      if (record && typeof record === 'object') {
        finalRecord = { ...record }
      } else if (Array.isArray(suggestions)) {
        finalRecord = {
          questions: suggestions.slice(0, 10),
          ts: ts || new Date().toISOString(),
          model: model || 'unknown',
        }
      } else {
        throw new Error('Invalid payload')
      }
      if (rationale && !finalRecord.rationale) finalRecord.rationale = rationale
      // Backward compatibility: persisted store may still be array
      const existing = interviewStepSuggestions[stepKey]
      const existingTs = existing?.ts ? new Date(existing.ts).getTime() : 0
      const newTs = finalRecord.ts
        ? new Date(finalRecord.ts).getTime()
        : Date.now()
      if (newTs >= existingTs) {
        interviewStepSuggestions[stepKey] = finalRecord
        persistInterviewSuggestions()
      }
      return { success: true }
    } catch (e) {
      return { success: false, error: e.message }
    }
  }
)

ipcMain.handle('app-get-settings', async () => {
  try {
    const store = await ensurePrefStore()
    return {
      version: app.getVersion(),
      platform: process.platform,
      // Known non-secret preferences
      theme: store.get('theme', 'auto'),
      selectedModel: store.get('selectedModel', 'gemini-1.5-flash'),
      compactView: store.get('compactView', false),
      portfolioLayout: store.get('portfolioLayout', 'grid'),
      selectedMicId: store.get('selectedMicId', ''),
      selectedSpeakerId: store.get('selectedSpeakerId', ''),
    }
  } catch {
    return { version: app.getVersion(), platform: process.platform }
  }
})

ipcMain.handle('app-update-settings', async (_event, settings) => {
  try {
    const store = await ensurePrefStore()
    if (!settings || typeof settings !== 'object') return { success: true }
    const allowed = [
      'theme',
      'selectedModel',
      'compactView',
      'portfolioLayout',
      'selectedMicId',
      'selectedSpeakerId',
    ]
    for (const k of allowed) {
      if (k in settings) store.set(k, settings[k])
    }
    return { success: true }
  } catch (error) {
    return { success: false, error: error.message }
  }
})

ipcMain.handle('app-get-version', () => {
  return app.getVersion()
})

ipcMain.handle('app-quit', () => {
  app.quit()
})

// Portfolio handlers - Enhanced implementations
function escapeHtml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
}

function generatePortfolioHTML(data) {
  const json = escapeHtml(JSON.stringify(data || {}, null, 2))
  return `<!doctype html><html><head><meta charset="utf-8"><title>Portfolio Export</title>
  <style>body{font-family:Arial,Helvetica,sans-serif;padding:24px} pre{white-space:pre-wrap;word-break:break-word;background:#f7f7f7;border:1px solid #ddd;padding:16px;border-radius:8px}</style>
  </head><body><h1>Portfolio Export</h1><pre>${json}</pre></body></html>`
}
ipcMain.handle('portfolio-export', async (_event, request) => {
  try {
    const {
      format = 'json',
      includeFeaturedOnly = false,
      includeAnalytics = false,
    } = request || {}

    // Get portfolio data (this should be retrieved from your data source)
    const portfolioData = { projects: [], skills: [], experience: [] } // placeholder

    let exportData
    if (includeFeaturedOnly) {
      exportData = {
        ...portfolioData,
        projects: portfolioData.projects.filter(project => project.featured),
      }
    } else {
      exportData = portfolioData
    }

    // Add analytics if requested
    if (includeAnalytics) {
      exportData.analytics = {
        exportedAt: new Date().toISOString(),
        totalProjects: exportData.projects?.length || 0,
        featuredProjects:
          exportData.projects?.filter(p => p.featured)?.length || 0,
        skillsCount: exportData.skills?.length || 0,
        exportFormat: format,
      }
    }

    let result
    switch (format) {
      case 'json':
        result = {
          success: true,
          data: JSON.stringify(exportData, null, 2),
          filename: `portfolio_${Date.now()}.json`,
          mimeType: 'application/json',
        }
        break

      case 'html':
        result = {
          success: true,
          data: generatePortfolioHTML(exportData),
          filename: `portfolio_${Date.now()}.html`,
          mimeType: 'text/html',
        }
        break

      case 'pdf':
        // Return HTML for renderer-side PDF conversion
        result = {
          success: true,
          data: generatePortfolioHTML(exportData),
          filename: `portfolio_${Date.now()}.html`,
          mimeType: 'text/html',
          requiresConversion: true,
          convertFrom: 'html',
        }
        break

      default:
        throw new Error(`Unsupported export format: ${format}`)
    }

    console.log(
      `[Portfolio] Exported ${exportData.projects?.length || 0} projects in ${format} format`
    )
    return result
  } catch (error) {
    console.error('[Portfolio] Export failed:', error)
    return { success: false, error: error.message }
  }
})

ipcMain.handle(
  'portfolio-import',
  async (_event, { filePath, format = 'auto' }) => {
    try {
      if (!fs.existsSync(filePath)) {
        throw new Error('File not found')
      }

      const fileContent = fs.readFileSync(filePath, 'utf8')
      let portfolioData

      // Auto-detect format if needed
      if (format === 'auto') {
        format = filePath.endsWith('.json') ? 'json' : 'unknown'
      }

      switch (format) {
        case 'json':
          try {
            portfolioData = JSON.parse(fileContent)
          } catch {
            throw new Error('Invalid JSON format')
          }
          break
        default:
          throw new Error(`Unsupported import format: ${format}`)
      }

      // Validate portfolio data
      const validation = validatePortfolioData(portfolioData)
      if (!validation.valid) {
        return {
          success: false,
          error: 'Invalid portfolio data structure',
          details: validation.errors,
        }
      }

      // Add import metadata
      portfolioData.importMetadata = {
        importedAt: new Date().toISOString(),
        originalFile: path.basename(filePath),
        importedProjects: portfolioData.projects?.length || 0,
      }

      console.log(
        `[Portfolio] Imported ${portfolioData.projects?.length || 0} projects from ${filePath}`
      )

      return {
        success: true,
        data: portfolioData,
        metadata: portfolioData.importMetadata,
      }
    } catch (error) {
      console.error('[Portfolio] Import failed:', error)
      return { success: false, error: error.message }
    }
  }
)

// HTML template for portfolio export
/* const portfolioHtmlTemplate = `
  <html>
  <head>
    <title>Portfolio</title>
    <style>
        body { font-family: 'Arial', sans-serif; line-height: 1.6; margin: 0; padding: 20px; background: #f4f4f4; }
        .container { max-width: 1000px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.1); }
        .header { text-align: center; margin-bottom: 40px; }
        .profile-img { width: 150px; height: 150px; border-radius: 50%; object-fit: cover; margin-bottom: 20px; }
        .section { margin-bottom: 40px; }
        .section h2 { color: #333; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
        .project { margin-bottom: 30px; padding: 20px; background: #f9f9f9; border-radius: 8px; }
        .project h3 { color: #667eea; margin-bottom: 10px; }
        .skills { display: flex; flex-wrap: wrap; gap: 10px; }
        .skill { background: #667eea; color: white; padding: 5px 15px; border-radius: 20px; font-size: 14px; }
        .featured { border-left: 5px solid #667eea; }
        @media print { body { background: white; } .container { box-shadow: none; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            ${profile.avatar ? `<img src="${profile.avatar}" alt="Profile" class="profile-img">` : ''}
            <h1>${profile.name || 'Gaming Professional'}</h1>
            <p style="font-size: 18px; color: #666;">${profile.tagline || 'Gaming Experience → Professional Success'}</p>
            ${profile.email ? `<p>Email: ${profile.email}</p>` : ''}
            ${profile.location ? `<p>Location: ${profile.location}</p>` : ''}
        </div>
        
        ${profile.summary ? `
        <div class="section">
            <h2>Professional Summary</h2>
            <p>${profile.summary}</p>
        </div>
        ` : ''}
        
        <div class="section">
            <h2>Gaming Projects & Achievements</h2>
            ${projects.map(project => `
                <div class="project ${project.featured ? 'featured' : ''}">
                    <h3>${project.title}${project.featured ? ' ⭐' : ''}</h3>
                    <p><strong>Role:</strong> ${project.role || 'Participant'}</p>
                    <p>${project.description}</p>
                    ${project.achievements ? `<p><strong>Achievements:</strong> ${project.achievements.join(', ')}</p>` : ''}
                    ${project.skills ? `<div class="skills">${project.skills.map(skill => `<span class="skill">${skill}</span>`).join('')}</div>` : ''}
                </div>
            `).join('')}
        </div>
        
        ${skills.length > 0 ? `
        <div class="section">
            <h2>Professional Skills</h2>
            <div class="skills">
                ${skills.map(skill => `<span class="skill">${skill.name || skill}</span>`).join('')}
            </div>
        </div>
        ` : ''}
        
        ${experiences.length > 0 ? `
        <div class="section">
            <h2>Professional Experience</h2>
            ${experiences.map(exp => `
                <div class="project">
                    <h3>${exp.title} at ${exp.company}</h3>
                    <p><em>${exp.duration || exp.startDate + ' - ' + (exp.endDate || 'Present')}</em></p>
                    <p>${exp.description}</p>
                </div>
            `).join('')}
        </div>
        ` : ''}
        
        <div style="text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; color: #666;">
            <p>Generated by NAVI - Gaming Career Assistant</p>
            <p>Generated on ${new Date().toLocaleDateString()}</p>
        </div>
    </div>
</body>
</html>`; */

// Helper function to validate portfolio data
function validatePortfolioData(data) {
  const errors = []

  if (!data || typeof data !== 'object') {
    return { valid: false, errors: ['Portfolio data must be an object'] }
  }

  // Validate projects array
  if (data.projects && !Array.isArray(data.projects)) {
    errors.push('Projects must be an array')
  } else if (data.projects) {
    data.projects.forEach((project, index) => {
      if (!project.title) {
        errors.push(`Project ${index} missing title`)
      }
    })
  }

  // Validate skills array
  if (data.skills && !Array.isArray(data.skills)) {
    errors.push('Skills must be an array')
  }

  // Validate profile object
  if (data.profile && typeof data.profile !== 'object') {
    errors.push('Profile must be an object')
  }

  return { valid: errors.length === 0, errors }
}

// Job search handlers - Enhanced implementations
ipcMain.handle('jobs-search', async (_event, filters = {}) => {
  try {
    const {
      query = '',
      location = '',
      studioId = '',
      roleType = '',
      experienceLevel = '',
      remote = false,
      salaryMin = 0,
      limit = 20,
      offset = 0,
      sources = [],
    } = filters

    // Attempt aggregated provider-based search first (browser-CORS-safe via main process)
    try {
      const { JobSearchService } = require('./services/JobSearchService.cjs')
      const mod = new JobSearchService()
      if (mod && typeof mod.searchJobs === 'function') {
        const result = await mod.searchJobs({
          query,
          location,
          remote,
          // Prefer provided sources, else a sensible default set
          sources:
            Array.isArray(sources) && sources.length
              ? sources
              : ['arbeitnow', 'jobicy'],
        })
        const agg = Array.isArray(result?.jobs)
          ? result.jobs
          : Array.isArray(result)
            ? result
            : []
        if (agg.length) {
          // Map to renderer-expected shape and apply additional filters
          let mapped = agg.map(job => ({
            id:
              job.id ||
              `${job.company || 'company'}-${job.title || 'role'}`
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-'),
            title: job.title,
            company: job.company,
            studioId: job.studioId,
            location: job.location || '',
            remote: !!job.remote,
            salary: job.salary || null,
            experienceLevel: job.experienceLevel || job.experience || 'mid',
            roleType: job.roleType || '',
            description: job.description || '',
            requirements: job.requirements || [],
            benefits: job.benefits || [],
            postedDate:
              job.postedDate || job.posted || new Date().toISOString(),
            applicationDeadline: job.applicationDeadline || null,
            tags: job.tags || [],
            source: job.source || 'aggregated',
            companyLogo: job.companyLogo || null,
            applicationUrl: job.url || job.applyUrl || null,
          }))

          if (studioId) mapped = mapped.filter(j => j.studioId === studioId)
          if (roleType) {
            const q = roleType.toLowerCase()
            mapped = mapped.filter(
              j =>
                (j.roleType || '').toLowerCase().includes(q) ||
                (j.title || '').toLowerCase().includes(q)
            )
          }
          if (experienceLevel) {
            const q = experienceLevel.toLowerCase()
            mapped = mapped.filter(j =>
              (j.experienceLevel || '').toLowerCase().includes(q)
            )
          }
          if (salaryMin > 0) {
            mapped = mapped.filter(j => {
              const s = j.salary
              if (!s) return false
              if (typeof s === 'string') {
                const m = s.match(/(\d[\d,]*)/g)
                if (!m) return false
                const nums = m
                  .map(n => parseInt(n.replace(/,/g, ''), 10))
                  .filter(Boolean)
                if (!nums.length) return false
                return Math.max(...nums) >= salaryMin
              }
              if (typeof s === 'object' && s.min)
                return Number(s.min) >= salaryMin
              return false
            })
          }

          const total = mapped.length
          const paginated = mapped.slice(offset, offset + limit)
          return {
            success: true,
            data: paginated,
            pagination: {
              total,
              limit,
              offset,
              hasMore: offset + limit < total,
            },
            filters,
          }
        }
      }
    } catch (e) {
      console.warn(
        '[Jobs] Aggregated provider search failed, falling back to mock:',
        e.message
      )
    }

    // Mock job search results with gaming industry focus
    let allJobs = [
      {
        id: 'riot_games_001',
        title: 'Senior Software Engineer - Game Systems',
        company: 'Riot Games',
        studioId: 'riot-games',
        location: 'Los Angeles, CA',
        remote: true,
        salary: { min: 150000, max: 220000, currency: 'USD' },
        experienceLevel: 'senior',
        roleType: 'Software Engineer',
        description:
          'Join our team building the core systems that power League of Legends and VALORANT. Work on high-performance game servers, data pipelines, and player-facing features.',
        requirements: [
          "Bachelor's degree in Computer Science or related field",
          '5+ years of software engineering experience',
          'Strong C++ and/or Go programming skills',
          'Experience with distributed systems',
          'Gaming industry experience preferred',
        ],
        benefits: [
          'Competitive salary and equity',
          'Full health, dental, and vision coverage',
          'Unlimited PTO',
          'Professional development budget',
          'Game development resources',
        ],
        postedDate: new Date(Date.now() - 86400000 * 3).toISOString(),
        applicationDeadline: new Date(Date.now() + 86400000 * 30).toISOString(),
        tags: [
          'C++',
          'Go',
          'Distributed Systems',
          'Gaming',
          'Server Infrastructure',
        ],
      },
      {
        id: 'blizzard_001',
        title: 'Game Designer - World of Warcraft',
        company: 'Blizzard Entertainment',
        studioId: 'blizzard',
        location: 'Irvine, CA',
        remote: false,
        salary: { min: 90000, max: 140000, currency: 'USD' },
        experienceLevel: 'mid',
        roleType: 'Game Designer',
        description:
          'Design and implement compelling gameplay systems for World of Warcraft. Collaborate with engineering, art, and QA teams to create engaging player experiences.',
        requirements: [
          "Bachelor's degree in Game Design, Computer Science, or related field",
          '3+ years of game design experience',
          'Strong understanding of MMORPGs and player progression systems',
          'Experience with scripting languages',
          'Portfolio of game design work',
        ],
        benefits: [
          'Health and wellness programs',
          'Retirement savings plan',
          'Flexible work arrangements',
          'Employee game library',
          'Professional development opportunities',
        ],
        postedDate: new Date(Date.now() - 86400000 * 7).toISOString(),
        applicationDeadline: new Date(Date.now() + 86400000 * 25).toISOString(),
        tags: [
          'Game Design',
          'MMO',
          'Scripting',
          'Player Systems',
          'World Building',
        ],
      },
      {
        id: 'epic_games_001',
        title: 'UI/UX Designer - Fortnite',
        company: 'Epic Games',
        studioId: 'epic-games',
        location: 'Cary, NC',
        remote: true,
        salary: { min: 85000, max: 130000, currency: 'USD' },
        experienceLevel: 'mid',
        roleType: 'UI/UX Designer',
        description:
          'Design intuitive and engaging user interfaces for Fortnite across multiple platforms. Focus on player experience and accessibility.',
        requirements: [
          "Bachelor's degree in Design, HCI, or related field",
          '3+ years of UI/UX design experience',
          'Proficiency in Figma, Sketch, or similar design tools',
          'Experience with game UI design principles',
          'Strong portfolio showcasing UI/UX work',
        ],
        benefits: [
          'Competitive salary and stock options',
          'Comprehensive health benefits',
          'Professional development budget',
          'Flexible PTO',
          'Work-from-home stipend',
        ],
        postedDate: new Date(Date.now() - 86400000 * 2).toISOString(),
        applicationDeadline: new Date(Date.now() + 86400000 * 28).toISOString(),
        tags: ['UI Design', 'UX Design', 'Figma', 'Game UI', 'Cross-Platform'],
      },
      {
        id: 'valve_001',
        title: 'Backend Engineer - Steam Platform',
        company: 'Valve Corporation',
        studioId: 'valve',
        location: 'Bellevue, WA',
        remote: false,
        salary: { min: 140000, max: 200000, currency: 'USD' },
        experienceLevel: 'senior',
        roleType: 'Software Engineer',
        description:
          'Build and maintain the backend systems that power Steam, serving millions of gamers worldwide. Work on scalable microservices and data infrastructure.',
        requirements: [
          '5+ years of backend engineering experience',
          'Strong knowledge of Python, Go, or C++',
          'Experience with microservices architecture',
          'Database design and optimization skills',
          'Understanding of distributed systems',
        ],
        benefits: [
          'No formal hierarchy - flat organization',
          'Choose your own projects',
          'Profit sharing program',
          'Full health and dental coverage',
          'Flexible work schedule',
        ],
        postedDate: new Date(Date.now() - 86400000 * 5).toISOString(),
        applicationDeadline: new Date(Date.now() + 86400000 * 45).toISOString(),
        tags: [
          'Backend',
          'Python',
          'Microservices',
          'Steam',
          'Distributed Systems',
        ],
      },
    ]

    // Apply filters
    let filteredJobs = allJobs

    if (query) {
      const queryLower = query.toLowerCase()
      filteredJobs = filteredJobs.filter(
        job =>
          job.title.toLowerCase().includes(queryLower) ||
          job.description.toLowerCase().includes(queryLower) ||
          job.tags.some(tag => tag.toLowerCase().includes(queryLower))
      )
    }

    if (location) {
      filteredJobs = filteredJobs.filter(job =>
        job.location.toLowerCase().includes(location.toLowerCase())
      )
    }

    if (studioId) {
      filteredJobs = filteredJobs.filter(job => job.studioId === studioId)
    }

    if (roleType) {
      filteredJobs = filteredJobs.filter(job => job.roleType === roleType)
    }

    if (experienceLevel) {
      filteredJobs = filteredJobs.filter(
        job => job.experienceLevel === experienceLevel
      )
    }

    if (remote) {
      filteredJobs = filteredJobs.filter(job => job.remote === true)
    }

    if (salaryMin > 0) {
      filteredJobs = filteredJobs.filter(
        job => job.salary && job.salary.min >= salaryMin
      )
    }

    // Apply pagination
    const paginatedJobs = filteredJobs.slice(offset, offset + limit)

    console.log(
      `[Jobs] Search returned ${paginatedJobs.length} of ${filteredJobs.length} jobs`
    )

    return {
      success: true,
      data: paginatedJobs,
      pagination: {
        total: filteredJobs.length,
        limit,
        offset,
        hasMore: offset + limit < filteredJobs.length,
      },
      filters: filters,
    }
  } catch (error) {
    console.error('[Jobs] Search failed:', error)
    return { success: false, error: error.message }
  }
})

ipcMain.handle(
  'jobs-get-studios',
  ignoreEvent(async (query = {}) => {
    try {
      // Use live database-backed service for studios
      const {
        DatabaseStudioService,
      } = require('./services/DatabaseStudioService.cjs')
      const databaseStudioService = new DatabaseStudioService()
      await databaseStudioService.init()

      // Support pagination via search API; fall back to full list if needed
      const {
        studios = [],
        total = 0,
        page = 1,
        pageSize = 50,
      } = (await databaseStudioService.searchStudios(query || {})) || {}

      const list = (studios || []).map(s => ({
        id: s.id,
        name: s.name,
        location: s.location,
        size: s.size,
        type: s.type,
        website: s.website,
      }))

      return {
        success: true,
        data: list,
        metadata: {
          totalStudios: total || list.length,
          page,
          pageSize,
          lastUpdated: new Date().toISOString(),
        },
      }
    } catch (error) {
      console.error('[Jobs] Get studios failed:', error)
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle(
  'jobs-save',
  ignoreEvent(async ({ jobId }) => {
    try {
      if (!jobId) {
        return { success: false, error: 'Job ID is required' }
      }

      // Add to saved jobs (in production, this would be saved to database)
      savedJobs.add(jobId)

      console.log(`[Jobs] Saved job ${jobId}`)
      return { success: true, message: 'Job saved successfully' }
    } catch (error) {
      console.error('[Jobs] Save job failed:', error)
      return { success: false, error: error.message }
    }
  })
)

// Saved jobs storage (in production, this would be a database)
let savedJobs = new Set()

ipcMain.handle(
  'jobs-get-saved',
  ignoreEvent(async () => {
    try {
      // Track whether a cover letter was provided (prevents unused variable warning)
      // In a real implementation, this would query saved jobs with full details
      const mockSavedJobs = Array.from(savedJobs).map(jobId => ({
        id: jobId,
        savedAt: new Date().toISOString(),
        // In practice, you'd fetch full job details here
        title: 'Software Engineer',
        company: 'Gaming Company',
        status: 'saved',
      }))

      console.log(`[Jobs] Retrieved ${mockSavedJobs.length} saved jobs`)

      return {
        success: true,
        data: mockSavedJobs,
        count: mockSavedJobs.length,
      }
    } catch (error) {
      console.error('[Jobs] Get saved jobs failed:', error)
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle(
  'jobs-apply',
  ignoreEvent(async ({ jobId, resume, coverLetter }) => {
    try {
      // Track whether a cover letter was provided (prevents unused variable warning)
      const coverLetterIncluded = !!(
        typeof coverLetter === 'string' && coverLetter.trim().length
      )

      // Track additional info (unused currently)
      // const hasAdditionalInfo = !!(typeof additionalInfo === 'string' && additionalInfo.trim().length);

      // Simulate application processing
      const applicationId = `app_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`

      // In a real implementation, this would:
      // 1. Format the resume appropriately
      // 2. Submit to the company's ATS
      // 3. Send confirmation emails
      // 4. Track application status

      if (!resume) {
        throw new Error('Resume data is required')
      }

      return {
        success: true,
        applicationId,
        message: 'Application submitted successfully',
        submittedAt: new Date().toISOString(),
        status: 'submitted',
        jobId,
        coverLetterIncluded,
        expectedResponseTime: '1-2 weeks',
        nextSteps: [
          'Application review by recruiter',
          'Initial screening if selected',
          'Technical/behavioral interviews',
          'Final decision',
        ],
      }
    } catch (error) {
      console.error('[Jobs] Job application failed:', error)
      return { success: false, error: error.message }
    }
  })
)

// Job matching endpoints (IPC)
ipcMain.handle(
  'jobs-match',
  ignoreEvent(async ({ profile, jobs }) => {
    try {
      if (!Array.isArray(jobs)) throw new Error('jobs must be an array')
      const results = jobMatching.calculateMatch(profile || {}, jobs)
      return { success: true, data: results }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
)
// Studio IPC handlers - Add these for studio operations
const {
  DatabaseStudioService,
} = require('./services/DatabaseStudioService.cjs')

ipcMain.handle(
  'studio-search',
  ignoreEvent(async request => {
    try {
      const databaseStudioService = new DatabaseStudioService()
      await databaseStudioService.init()

      const result = await databaseStudioService.searchStudios(request)
      return { success: true, data: result }
    } catch (error) {
      console.error('[Studio] Search failed:', error)
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle(
  'studio-get-by-id',
  ignoreEvent(async ({ id }) => {
    try {
      const databaseStudioService = new DatabaseStudioService()
      await databaseStudioService.init()

      const studio = await databaseStudioService.getStudio(id)
      if (!studio) {
        return { success: false, error: `Studio with id ${id} not found` }
      }

      return { success: true, data: studio }
    } catch (error) {
      console.error('[Studio] Get by ID failed:', error)
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle(
  'studio-get-health',
  ignoreEvent(async () => {
    try {
      const databaseStudioService = new DatabaseStudioService()
      await databaseStudioService.init()

      const health = await databaseStudioService.getHealth()
      return { success: true, data: health }
    } catch (error) {
      console.error('[Studio] Get health failed:', error)
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle(
  'studio-import',
  ignoreEvent(async data => {
    try {
      const databaseStudioService = new DatabaseStudioService()
      await databaseStudioService.init()

      const result = await databaseStudioService.importAllStudios(data)
      return { success: true, data: result }
    } catch (error) {
      console.error('[Studio] Import failed:', error)
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle(
  'studio-export',
  ignoreEvent(async () => {
    try {
      const databaseStudioService = new DatabaseStudioService()
      await databaseStudioService.init()

      const result = await databaseStudioService.exportStudios()
      return { success: true, data: result }
    } catch (error) {
      console.error('[Studio] Export failed:', error)
      return { success: false, error: error.message }
    }
  })
)

ipcMain.handle(
  'studio-get-statistics',
  ignoreEvent(async () => {
    try {
      const databaseStudioService = new DatabaseStudioService()
      await databaseStudioService.init()

      const stats = await databaseStudioService.getStatistics()
      return { success: true, data: stats }
    } catch (error) {
      console.error('[Studio] Get statistics failed:', error)
      return { success: false, error: error.message }
    }
  })
)

// Ensure single instance
const gotTheLock = app.requestSingleInstanceLock()

if (!gotTheLock) {
  app.quit()
} else {
  app.on('second-instance', () => {
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore()
      mainWindow.focus()
    }
  })
}
