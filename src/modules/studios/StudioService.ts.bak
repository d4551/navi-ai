
import { StudioRepository } from "@/modules/db/repositories/studios";
// Use interview GameStudio shape which matches our GAMING_STUDIOS constants and normalized storage
import type { GameStudio } from "@/shared/types/interview";
export type { GameStudio } from "@/shared/types/interview";
// Keep these enums loosely typed for filters (we allow category fallback as type)
export type StudioType =
  | "AAA"
  | "Indie"
  | "Mobile"
  | "VR/AR"
  | "Platform"
  | "Esports"
  | "Unknown";
export type GameGenre =
  | "Action"
  | "RPG"
  | "Strategy"
  | "Puzzle"
  | "Simulation"
  | "Sports"
  | "Racing"
  | "Shooter"
  | "Platformer"
  | "Horror"
  | "MMORPG"
  | "MOBA"
  | "Battle Royale"
  | "Roguelike"
  | "Sandbox";
export type Platform =
  | "PC"
  | "Console"
  | "Mobile"
  | "VR"
  | "AR"
  | "Web"
  | "Switch"
  | "PlayStation"
  | "Xbox"
  | "Steam";
import { logger } from "@/shared/utils/logger";

 param($m) $block=$m.Groups[1].Value; if($block -match 'page\?:'){$m.Value}else{$m.Value.Replace($block, ($block+"\n  page?: number;\n  pageSize?: number;\n"))} 

export interface StudioSearchResult {
  studios: GameStudio[];
  total: number;
  filtered: number;
  facets: {
    types: Record<string, number>;
    locations: Record<string, number>;
    sizes: Record<string, number>;
    genres: Record<string, number>;
  };
}

class CanonicalStudioService {
  private repository = StudioRepository;
  private cache = new Map();

  async initialize(): Promise<void> {
    try {
      await this.repository.ensureInitialized();
      logger.info("[GAME] Studio Service initialized");
    } catch (error) {
      logger.error("Failed to initialize Studio Service:", error);
      throw error;
    }
  }

  async searchStudios(
    filters: StudioFilters = {},
  ): Promise<StudioSearchResult> {
    const cacheKey = JSON.stringify(filters);
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.data;
    }

    // Prefer live DB-backed IPC if available (Electron)
    try {
      const anyWindow: any = typeof window !== 'undefined' ? (window as any) : {};
      const api = anyWindow.api || anyWindow.electronAPI || {};
      if (api.studios?.search) {
        // Map UI filters to backend query
         param($m) $block=$m.Groups[1].Value; $add="\n        if (Array.isArray(filters.technologies) && filters.technologies.length) {\n          query.technologies = filters.technologies;\n        }\n        if (filters.page) query.page = filters.page;\n        if (filters.pageSize) query.pageSize = filters.pageSize;\n        "; $m.Value -replace "\Q$block\E", ($add+$block)  support via `name` if present on filters
        if ((filters as any).query) query.name = (filters as any).query;

        const res = await api.studios.search(query);
        const studios = Array.isArray(res?.studios) ? res.studios : [];
        const result: StudioSearchResult = {
          studios,
          total: Number(res?.total ?? studios.length) || studios.length,
          filtered: studios.length,
          facets: this.calculateFacets(studios as any),
        };
        this.cache.set(cacheKey, { data: result, timestamp: Date.now() });
        return result;
      }
    } catch (e) {
      logger.warn('[StudioService] IPC search fallback due to error:', e);
    }

    // Fallback to in-renderer repository filtering when IPC not available
    try {
      const all = await this.repository.getAll();
      let studios = [...(all as unknown as GameStudio[])];
      if (filters.type) {
        const t = String(filters.type).toLowerCase();
        studios = studios.filter((studio) => {
          const type = (studio as any).type ? String((studio as any).type).toLowerCase() : '';
          const category = (studio as any).category ? String((studio as any).category).toLowerCase() : '';
          return type === t || category === t;
        });
      }
      if (filters.location) {
        const location = filters.location.toLowerCase();
        studios = studios.filter((studio) => {
          const hq = (studio as any).headquarters ? String((studio as any).headquarters).toLowerCase() : '';
          const loc = (studio as any).location ? String((studio as any).location).toLowerCase() : '';
          return hq.includes(location) || loc.includes(location);
        });
      }
      if (filters.size) {
        studios = studios.filter(
          (studio) => String((studio as any).size || '').toLowerCase() === String(filters.size).toLowerCase(),
        );
      }
      const result: StudioSearchResult = {
        studios,
        total: (all as any[]).length,
        filtered: studios.length,
        facets: this.calculateFacets(studios as any),
      };
      this.cache.set(cacheKey, { data: result, timestamp: Date.now() });
      return result;
    } catch (error) {
      logger.error('Studio search failed:', error);
      throw error;
    }
  }

  async getStudioById(id: string): Promise<GameStudio | null> {
    return await this.repository.getById(id);
  }

  async findStudioByName(name: string): Promise<GameStudio | null> {
    return await this.repository.findByCompanyName(name);
  }

  async getFavoriteStudios(): Promise<GameStudio[]> {
    const favoriteIds = await this.repository.getFavorites();
    const studios = [];

    for (const id of favoriteIds) {
      const studio = await this.repository.getById(id);
      if (studio) studios.push(studio);
    }

    return studios;
  }

  async toggleFavorite(studioId: string): Promise<boolean> {
    const isFavorite = await this.repository.isFavorite(studioId);

    if (isFavorite) {
      await this.repository.removeFavorite(studioId);
      return false;
    } else {
      await this.repository.addFavorite(studioId);
      return true;
    }
  }

  async isFavorite(studioId: string): Promise<boolean> {
    return await this.repository.isFavorite(studioId);
  }

    return await this.repository.getSuggestions(query, limit);
  }

  async getStudiosByCategory(category: string): Promise<GameStudio[]> {
    return await this.repository.getByCategory(category);
  }

  async getStudiosByRegion(region: string): Promise<GameStudio[]> {
    return await this.repository.getByRegion(region);
  }

  private calculateFacets(studios: GameStudio[]) {
    const facets = {
      types: {} as Record<string, number>,
      locations: {} as Record<string, number>,
      sizes: {} as Record<string, number>,
      genres: {} as Record<string, number>,
    };

    studios.forEach((studio) => {
      const type = (studio as any).type || (studio as any).category;
      if (type) {
      }

      const loc = (studio as any).location || (studio as any).headquarters;
      if (loc) {
      }

      const size = (studio as any).size;
      if (size) {
      }

      ((studio as any).gameGenres || []).forEach((genre: string) => {
      });
    });

    return facets;
  }

  clearCache(): void {
    this.cache.clear();
  }

  // --- Open knowledge ingestion (Wikidata/Wikipedia/DBpedia/GitHub) ---
  // Lightweight inbound type (avoid import dependency)
  async ingestOpenData(
    openStudios: Array<{
      name: string;
      website?: string;
      founded?: any;
      country?: string;
      headquarters?: string;
      summary?: string;
      employees?: any;
      sources?: string[];
    }>,
  ): Promise<{ created: number; updated: number; total: number }> {
    try {
      }

      // Load current studios once
      const current = await this.repository.getAll();
      const indexByKey = new Map<string, any>();
      for (const s of current) {
        indexByKey.set(this.normalizeName((s as any).name), s);
      }


      for (const inbound of openStudios) {
        const key = this.normalizeName(inbound.name);
        if (!key) continue;

        const existing = indexByKey.get(key);
        if (existing) {
          // Merge minimal enrichment (do not override non-empty fields)
          const updates: any = {};
          if (!existing.description && inbound.summary)
            updates.description = inbound.summary;
          if (!existing.headquarters && inbound.headquarters)
            updates.headquarters = inbound.headquarters;
          if (!existing.location && inbound.country)
            updates.location = inbound.country;
          if (!existing.size && inbound.employees)
            updates.size = String(inbound.employees);
          if (
            inbound.website
          )
            updates.websites = [inbound.website];
          if (!existing.founded && inbound.founded)
            updates.founded = inbound.founded;

            try {
              await this.repository.update(existing.id, updates);
              updated++;
            } catch (e) {
              logger.warn(
                "Studio update failed (ingest):",
                (existing as any).name,
                e,
              );
            }
          }
        } else {
          // Create minimal studio record
          const record: any = {
            name: inbound.name,
            description: inbound.summary || "",
            location: inbound.country || inbound.headquarters || "",
            headquarters: inbound.headquarters || "",
            websites: inbound.website ? [inbound.website] : [],
            size: inbound.employees ? String(inbound.employees) : "",
            founded: inbound.founded || undefined,
            aliases: [],
            locations: [],
            reputation: {},
            hiringData: {},
            dataSource: Array.isArray(inbound.sources)
              ? inbound.sources
              : ["open-knowledge"],
          };
          try {
            await this.repository.create(record);
            created++;
          } catch (e) {
            logger.warn("Studio create failed (ingest):", inbound.name, e);
          }
        }
      }

      // Clear service cache so new searches reflect updates
      this.clearCache();
      return { created, updated, total: openStudios.length };
    } catch (error) {
      logger.error("Ingest open data failed:", error);
    }
  }

  private normalizeName(name: string): string {
    return String(name || "")
      .toLowerCase()
      .replace(
        /\s+(inc|llc|ltd|limited|corporation|corp|co|studio|studios|games|gaming|entertainment)\.?$/gi,
        "",
      )
      .replace(/[^\w\s]/g, "")
      .trim();
  }
}

// Export singleton instance
export const studioService = new CanonicalStudioService();
export default studioService;

